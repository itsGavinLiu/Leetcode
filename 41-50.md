## Leetcode 41

Question: Given an unsorted integer array nums, return the smallest missing positive integer.

Analysis:
- The idea is to find the smallest number from 1 to n that does not exist in this array. The brute force way is to search such a value one by one. The time complexity is `O(n^2)`, and space complexity is `O(1)`. Unfortunately, it passed 169/173 tests and time limit exceeded.
- We can improve the efficiency by sorting the array and searching using binary search.
- Noticing that the for `nums` with length `n`, the possible result is in the range of `[1 : n + 1]`. The most intuitive way is to create an new array to count the frequency. The will be `n + 1` spots and they are initialized as `0`. Everytime we encounter a number in `nums`, we increment the relative index by 1. The time complexity is `O(n)` and space complexity is `O(n)`. 
- We can further optimize this method using **hashing**. We can simply update the original `nums` to avoid introducing extra space. First, we add `0` to `nums` so that it will cover all possible integers. Second, we loop through the array and set integers which are beyond the solution range to be `0`. Third, we use the array index as the hash to restore the frequency of each number. Specifically, we loop thorugh the array again and overwrite the spot at the index of the item plus the length of the array using **modulo operation**. Then, we loop through the array and divide each integer by the `n`. Starting from index 1, the first index whose integer equals to `0` is the answer. 

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.append(0)
        n = len(nums)
        
        for i in range(n):
            if nums[i] < 0 or nums[i] >= n:
                nums[i] = 0
        
        for i in range(n):
            nums[nums[i] % n] += n
        
        for i in range(1, n):
            if nums[i] // n == 0:
                return i
        return n
```

## Leetcode 42

Question: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

Analysis:
