## Leetcode 61

Question: Given the `head` of a linked list, rotate the list to the right by `k` places.

Analysis:
- We can create a helper function that rotates the last node. After that, we use a loop to repeat this function `k` times.
- However, that is very complex. We notice that if `k` is greater than `n` the length of this linked list, we can only rotate `k%n` times. Actually, we can connect the link and make it to a circle. Once we get the number of ratations, we can iterate the linked list and break the circle.

```python
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if k == 0 or not head or not head.next:
            return head
        
        n = 1
        cur = head
        while cur.next:
            cur = cur.next
            n += 1
        
        add = n - k % n
        if add == 0:
            return head
        
        cur.next = head
        while add:
            cur = cur.next
            add -= 1
            
        res = cur.next
        cur.next = None
        return res
```

## Leetcode 62

Question: Given the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

Analysis:
- We can use dynamic programming to solve this problem. The state function is `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.


```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n for _ in range(m)]
        
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
                
        return dp[-1][-1]
```

## Leetcode 63

Question: 
An obstacle and space are marked as `1` or `0` respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

Analysis:
- Inspired by Leetcode 62, we are going to use dynamic programming. This time we need to first go over row and then go over column to check whether ther is an obstacle. Later, we can use the same state function.


```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        
        if obstacleGrid[0][0] == 1:
            return 0
        obstacleGrid[0][0] = 1
        for i in range(1, m):
            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)
        
        for j in range(1, n):
            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)
        
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]
                else:
                    obstacleGrid[i][j] = 0
        return obstacleGrid[m - 1][n - 1]
```
