## Leetcode 71

Question: Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, 
convert it to the simplified canonical path.

Analysis:
- For directories, we can go deeper or come back. The final result depends on the memorization of all valid elements and therefore, we can use `stack` to keep track of it. The algorithm is first, if the stack is not empty and we meet `..`, we pop one element from stack to go back. Second, if the element exists and is not `.`, we put it into the end of the stack. Fianlly, we join the result.

```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        
        for p in path.split('/'):
            if p == '..':
                if stack:
                    stack.pop()
            elif p and p != '.':
                stack.append(p)
        return '/' + '/'.join(stack)
```

## Leetcode 72

Question: Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.

Analysis:
- If a problem consistes many sub-problems and every state is transferred from the previous state, then we can use dynamic programming. First thing first, we have to understand what is `dp[i][j]`. In this case, it means the edit distance from `word1[i]` to `word2[j]`. If `i` equals 0, it means the edit distance from an empty string. After that, we need to consider state function. We have to consider three operations. 
- `replace`: `dp[i][j] = dp[i-1][j-1] + 1`.  
- `delete`: `dp[i][j] = dp[i-1][j] + 1`.
- `insert`: ``dp[i][j] = dp[i][j-1] + 1`.


